"""
Generate a video of the scene. It Runs on the nerfstudio-docker-tcnn environment.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

import tyro

from thermo_nerf.render.renderer import Renderer
from thermo_nerf.rendered_image_modalities import RenderedImageModality


@dataclass
class RenderTrajectoryCLIArgs:
    """Stores input arguments used for rendering."""

    model_uri: str
    """Path to model."""
    camera_path_filename: Path
    """Filename of the camera path to render."""
    dataset_path: Path | None = None
    """Path to a dataset containing a transforms.json file generated by COLMAP.
    Used to query the dataset first pose to generate a spiral trajectory"""
    save_video: bool = True
    """Save the video to a file in `output_dir`"""
    save_images: bool = False
    """Save images to a folder in `output_dir`"""
    rendered_image_modalities: list[RenderedImageModality] = field(
        default_factory=lambda: [
            RenderedImageModality.RGB,
            RenderedImageModality.THERMAL,
        ]
    )
    """Name of the renderer outputs to use: rgb, depth, accumulation."""
    downscale_factor: int = 1
    """Downscale the size of the images"""
    output_dir: Path = Path("./outputs")
    """Name of the output folder"""
    seconds: float = 5.0
    """How long the video should be"""
    eval_num_rays_per_chunk: Optional[int] = None
    """Specifies number of rays per chunk during eval"""

    def __post_init__(self) -> None:
        try:
            open(self.camera_path_filename, "r", encoding="utf-8")
        except FileExistsError:
            raise FileExistsError("The camera path could not be resolved")

    @property
    def transform_path(self) -> Path:
        if self.dataset_path is None:
            raise RuntimeError("Cannot get transform path without a dataset")
        return Path(self.dataset_path, "transforms.json")


def main() -> None:
    tyro.extras.set_accent_color("bright_yellow")
    render_trajectory_args = tyro.cli(RenderTrajectoryCLIArgs)

    camera_path = Renderer.load_cameras(
        render_trajectory_args.camera_path_filename,
        rendered_resolution_scaling_factor=1.0
        / render_trajectory_args.downscale_factor,
    )

    renderer = Renderer.from_pipeline_path(
        Path(render_trajectory_args.model_uri),
        render_trajectory_args.transform_path,
        render_trajectory_args.eval_num_rays_per_chunk,
    )

    renderer.render(
        rendered_image_modalities=render_trajectory_args.rendered_image_modalities,
        cameras=camera_path,
    )

    if render_trajectory_args.save_images:
        renderer.save_images(
            render_trajectory_args.rendered_image_modalities,
            render_trajectory_args.output_dir,
        )

    if render_trajectory_args.save_video:
        renderer.save_gif(
            render_trajectory_args.rendered_image_modalities,
            render_trajectory_args.seconds,
            render_trajectory_args.output_dir,
        )


if __name__ == "__main__":
    main()
